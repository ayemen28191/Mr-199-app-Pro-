# دليل كامل: إدارة الجداول وRLS وسياسات تلقائية — Supabase
 
 
وصف: وثيقة شاملة "من الصفر إلى الإنتاج" لإضافة تبويبة إدارة واكتشاف الجداول، تفعيل/تعطيل RLS، إنشاء سياسات تلقائية، ونظام تحليلي ذكي للتوصية بالسياسات والتقديرات الزمنية. مناسبة للاستخدام مباشرة في SQL editor وكمخطط للتنفيذ الخلفي والواجهة.
 
  
## الفهرس
 
 
1. المقدمة والسيناريو
 
2. المتطلبات والافتراضات
 
3. البنية المعمارية (Architecture)
 
4. مخطط التنفيذ خطوة بخطوة
 
5. SQL جاهز: إنشاء الـ schema والدوال وجداول السجلات
 
6. كود Backend (Node.js/Express) — ملفات كاملة
 
7. واجهة المستخدم (React) — تصميم ومكونات جاهزة
 
8. الخوارزمية التحليلية (Heuristics) + اقتراحات ML مستقبلية
 
9. آليات الأمان والـ Audit وعمليات النسخ الاحتياطي
 
10. اختبار، نشر، واسترجاع (rollback)
 
11. قوائم مراجعة (Checklist) وملخص التنفيذ
 
12. ملاحق: أمثلة تنفيذية، استعلامات فحص، رسائل خطأ شائعة وحلول
 

  
# 1) المقدمة والسيناريو
 
**الهدف:**إضافة تبويبة في صفحة نظام الذكي قاعدة البيانات تحكم مشروعك على Supabase تتيح:
 
 
- اكتشاف جميع الجداول (باستثناء الأنظمة).
 
- إظهار حالة RLS لكل جدول (مفعّل/معطّل/قسر).
 
- تفعيل أو تعطيل RLS آمنًا عبر backend أو دوال مُوقّعة.
 
- إنشاء/تعديل/حذف سياسات RLS تلقائيًا استنادًا إلى بنية الجدول.
 
- تقديم توصيات ذكيّة حول حاجة الجدول إلى RLS ونموذج السياسة المقترح مع تقدير زمن التنفيذ.
 
- حفظ سجلات التغيير (audit log) وتقديم واجهة للمراجعة.
 

 
**السيناريو العملي:** مشغل النظام (Admin) يريد بسرعة فحص قاعدة بيانات الإنتاج قبل ترحيل ميزة جديدة. يفتح تبويبة "RLS Manager"، يستعرض جدولًا من جميع الجداول، يرى توصية النظام (مطلوب/مستحسن/غير ضروري)، يراجع SQL المقترحة للسياسة، ويمكنه تطبيق السياسة بضغطة زر. كل تغيير يُسجل ويُشعر الفريق (اختياري).
 
# 2) المتطلبات والافتراضات
 
 
- قاعدة بيانات PostgreSQL (Supabase-managed) مع إمكانية تنفيذ DDL (ALTER TABLE, CREATE POLICY) باستخدام مفتاح خدمة (service_role) أو حساب مالك DB.
 
- وصول آمن للخادم (Backend) إلى `SUPABASE_DB_URL` أو استخدام `supabase-js` مع `SERVICE_ROLE_KEY` على الخادم.
 
- بيئة Node.js (نسخة 18+ موصى بها) لتنفيذ مثال backend. ممكن استبدال Flask أو أي لغة أخرى بنفس المنطق.
 
- واجهة React (اختياري) لعرض DataGrid والـ Sidebar التحليلي.
 

 
# 3) البنية المعمارية (مختصر)
 `Admin UI (React)   ↕ (HTTPS, Authenticated Admin) Backend (Node.js/Express)   - يتصل بـ Supabase (SUPABASE_DB_URL or Service Role)   - يستدعي RPC admin.* أو ينفذ SQL مباشرة   - يسجل الأحداث في audit table Database (Postgres / Supabase)   - admin schema (functions)   - audit table   - تطبيق سياسات RLS ` 
ملاحظات أمنية: لا تقم أبداً بوضع `SERVICE_ROLE_KEY` في الواجهة الأمامية. كل العمليات الإدارية تتم عبر backend موثوق أو دوال `SECURITY DEFINER` مملوكة لمالك موثوق.
 
# 4) مخطط التنفيذ خطوة بخطوة (High-level roadmap)
 
 
1. إنشاء schema `admin` ودوال RPC (list_tables_with_meta, toggle_rls, create_policy, list_policies).
 
2. إنشاء جدول audit: `admin.audit_log` لتسجيل كل تغيير.
 
3. نشر SQL في بيئة staging واختبار.
 
4. بناء backend: endpoints محمية (`/admin/tables`, `/admin/toggle-rls`, `/admin/create-policy`, `/admin/audit`) يتصل بالدوال أو ينفّذ SQL.
 
5. بناء واجهة: DataGrid + Sidebar توصيات + modals لتأكيد التغييرات.
 
6. إضافة ميزات متقدمة: حفظ تفضيلات، التعلم من السلوك (ML)، إرسال إشعارات.
 

  
# 5) SQL جاهز: إنشاء الـ schema، الدوال، جدول السجل والقوالب
 
 
**ملاحظة أمان:** الدوال هنا مُعلّمة `SECURITY DEFINER`. بعد الإنشاء تأكّد أن مالك هذه الدوال هو حساب موثوق (owner) — عادةً الحساب الذي تملكه أنت أو service_role.
 
 `-- ---------- admin schema & audit table ---------- CREATE SCHEMA IF NOT EXISTS admin;  -- جدول audit لتسجيل كل تغيّر CREATE TABLE IF NOT EXISTS admin.audit_log (   id bigserial PRIMARY KEY,   occurred_at timestamptz NOT NULL DEFAULT now(),   actor text, -- معرف المستخدم أو السيرفر   action text, -- e.g. 'toggle_rls', 'create_policy'   target_schema text,   target_table text,   payload jsonb, -- تفاصيل إضافية   statement text -- الSQL التي تم تنفيذها (اختياري) );  -- دالة: قائمة الجداول مع حالة RLS وحجم تقريبي CREATE OR REPLACE FUNCTION admin.list_tables_with_meta() RETURNS TABLE(     schema_name text,     table_name text,     relrowsecurity boolean,     relforcerowsecurity boolean,     reltuples bigint ) LANGUAGE sql SECURITY DEFINER AS $$     SELECT n.nspname, c.relname, c.relrowsecurity, c.relforcerowsecurity, c.reltuples     FROM pg_class c     JOIN pg_namespace n ON n.oid = c.relnamespace     WHERE c.relkind = 'r'       AND n.nspname NOT IN ('pg_catalog','information_schema'); $$;  -- دالة: toggle RLS مع تسجيل في audit CREATE OR REPLACE FUNCTION admin.toggle_rls(_schema text, _table text, _enable boolean, _actor text DEFAULT NULL) RETURNS text LANGUAGE plpgsql SECURITY DEFINER AS $$ DECLARE     stmt text; BEGIN     IF _enable THEN         stmt := format('ALTER TABLE %I.%I ENABLE ROW LEVEL SECURITY', _schema, _table);     ELSE         stmt := format('ALTER TABLE %I.%I DISABLE ROW LEVEL SECURITY', _schema, _table);     END IF;      EXECUTE stmt;      INSERT INTO admin.audit_log(actor, action, target_schema, target_table, payload, statement)     VALUES(_actor, 'toggle_rls', _schema, _table, jsonb_build_object('enable', _enable), stmt);      RETURN 'ok'; END; $$;  -- دالة: إنشاء سياسة عامة (create policy) CREATE OR REPLACE FUNCTION admin.create_policy(     p_schema text,     p_table text,     p_policy_name text,     p_command text,     p_using text,     p_with_check text DEFAULT NULL,     p_actor text DEFAULT NULL ) RETURNS text LANGUAGE plpgsql SECURITY DEFINER AS $$ DECLARE     stmt text; BEGIN     stmt := format(         'CREATE POLICY %I ON %I.%I FOR %s USING (%s) %s',         p_policy_name, p_schema, p_table, p_command, p_using,         CASE WHEN p_with_check IS NOT NULL THEN format('WITH CHECK (%s)', p_with_check) ELSE '' END     );      EXECUTE stmt;      INSERT INTO admin.audit_log(actor, action, target_schema, target_table, payload, statement)     VALUES(p_actor, 'create_policy', p_schema, p_table, jsonb_build_object('policy', p_policy_name, 'command', p_command), stmt);      RETURN 'created'; END; $$;  -- دالة: حذف سياسة CREATE OR REPLACE FUNCTION admin.drop_policy(p_schema text, p_table text, p_policy_name text, p_actor text DEFAULT NULL) RETURNS text LANGUAGE plpgsql SECURITY DEFINER AS $$ DECLARE     stmt text; BEGIN     stmt := format('DROP POLICY IF EXISTS %I ON %I.%I', p_policy_name, p_schema, p_table);     EXECUTE stmt;      INSERT INTO admin.audit_log(actor, action, target_schema, target_table, payload, statement)     VALUES(p_actor, 'drop_policy', p_schema, p_table, jsonb_build_object('policy', p_policy_name), stmt);      RETURN 'dropped'; END; $$;  -- دالة مساعدة: استعلام أعمدة جدول CREATE OR REPLACE FUNCTION admin.table_columns(p_schema text, p_table text) RETURNS TABLE(column_name text, data_type text) LANGUAGE sql SECURITY DEFINER AS $$     SELECT column_name, data_type     FROM information_schema.columns     WHERE table_schema = p_schema AND table_name = p_table; $$;  -- أمثلة لقوالب سياسات (يمكن استدعاؤها عبر admin.create_policy) -- user isolation (Supabase: auth.uid()) -- SELECT admin.create_policy('public','orders','user_isolation','ALL','user_id = auth.uid()','user_id = auth.uid()','system');  -- tenant isolation (باستخدام set_config/current_setting) -- SELECT admin.create_policy('public','tenants_data','tenant_isolation','ALL','tenant_id = current_setting(''app.current_tenant'')::uuid','tenant_id = current_setting(''app.current_tenant'')::uuid','system');  -- readonly policy -- SELECT admin.create_policy('public','countries','readonly','SELECT','true',NULL,'system'); `  
# 6) كود Backend (Node.js/Express) — ملفات كاملة
 
 
يتضمن: package.json، app.js، routes/admin.js، وملف .env.example
 
 
## 6.1 package.json (مختصر)
 `{   "name": "supabase-rls-admin",   "version": "1.0.0",   "type": "module",   "scripts": {     "start": "node app.js",     "dev": "nodemon app.js"   },   "dependencies": {     "express": "^4.18.2",     "pg": "^8.10.0",     "dotenv": "^16.0.0",     "helmet": "^6.0.0",     "cors": "^2.8.5",     "express-rate-limit": "^6.7.0"   } } ` 
## 6.2 .env.example
 `PORT=8080 SUPABASE_DB_URL=postgres://... (SUPABASE_DB_URL with owner/service_role) ADMIN_API_KEY=some-admin-jwt-or-secret ` 
## 6.3 app.js (Entrypoint)
 `import express from 'express'; import dotenv from 'dotenv'; import helmet from 'helmet'; import cors from 'cors'; import rateLimit from 'express-rate-limit'; import adminRoutes from './routes/admin.js'; import bodyParser from 'body-parser';  dotenv.config(); const app = express(); app.use(helmet()); app.use(cors()); app.use(bodyParser.json());  const limiter = rateLimit({ windowMs: 15 * 60 * 1000, max: 200 }); app.use(limiter);  app.use('/admin', adminRoutes);  app.get('/', (req, res) => res.send('RLS Admin API'));  const port = process.env.PORT || 8080; app.listen(port, () => console.log(`Server running on ${port}`)); ` 
## 6.4 routes/admin.js
 `import express from 'express'; import { Client } from 'pg';  const router = express.Router();  // middleware for simple API key admin auth router.use((req, res, next) => {   const key = req.headers['x-admin-key'] || req.query.admin_key;   if (!key || key !== process.env.ADMIN_API_KEY) return res.status(401).json({ error: 'Unauthorized' });   next(); });  function getClient() {   return new Client({ connectionString: process.env.SUPABASE_DB_URL }); }  // GET /admin/tables router.get('/tables', async (req, res) => {   const client = getClient();   try {     await client.connect();     const { rows } = await client.query('SELECT * FROM admin.list_tables_with_meta()');     // إضافة درجات الحساسية والتقدير الزمني هنا (ببساطة في الباك)     const enriched = rows.map(r => {       const score = computeSensitivityScore(r.schema_name, r.table_name); // function to implement       const estimate = estimateTime(r.reltuples, score);       return { ...r, sensitivity_score: score, estimate_time: estimate };     });     await client.end();     res.json(enriched);   } catch (err) {     await client.end();     res.status(500).json({ error: err.message });   } });  // POST /admin/toggle-rls {schema, table, enable, actor} router.post('/toggle-rls', async (req, res) => {   const { schema, table, enable, actor } = req.body;   const client = getClient();   try {     await client.connect();     const q = 'SELECT admin.toggle_rls($1,$2,$3,$4) as result';     const { rows } = await client.query(q, [schema, table, enable, actor || 'web-admin']);     await client.end();     res.json(rows[0]);   } catch (err) {     await client.end();     res.status(500).json({ error: err.message });   } });  // POST /admin/create-policy {schema, table, name, command, using, with_check, actor} router.post('/create-policy', async (req, res) => {   const { schema, table, name, command, using, with_check, actor } = req.body;   const client = getClient();   try {     await client.connect();     const q = 'SELECT admin.create_policy($1,$2,$3,$4,$5,$6,$7) as result';     const { rows } = await client.query(q, [schema, table, name, command, using, with_check || null, actor || 'web-admin']);     await client.end();     res.json(rows[0]);   } catch (err) {     await client.end();     res.status(500).json({ error: err.message });   } });  // Helper functions (بسيطة، يمكن تحسينها لاحقاً) function computeSensitivityScore(schema, table) {   // مبدئي: استنادًا لأسماء الجداول أو استعلام أعمدة (ببساطة الآن عدد نقاط عشوائية)   // يُنصح استدعاء admin.table_columns للحصول على التفاصيل الحقيقية   if (/user|auth|account|order|payment/.test(table)) return 80;   if (/log|audit|events/.test(table)) return 40;   return 10; } function estimateTime(reltuples, score) {   if (reltuples < 1000) return '5-10m';   if (reltuples < 100000) return '20-40m';   return score > 50 ? '1-2h' : '30-60m'; }  export default router; `  
# 7) واجهة المستخدم (React) — اقتراح تصميم ومكوّنات
 
 
هنا سنعرض مكوّن React واحد مركزي (صفحة) يحتوي DataGrid وSidebar.
 
 
### 7.1 متطلبات
 
 
- React 18
 
- مكتبة جدول: يمكنك استخدام MUI DataGrid أو TanStack Table
 
- axios/fetch لاستدعاء API
 

 
### 7.2 سلوك الواجهة
 
 
- صفحة تعرض لائحة الجداول (GET /admin/tables)
 
- عند اختيار جدول: تظهر لوحة جانبية (Sidebar) تعرض الحساسية، السياسة المقترحة (SQL)، زر تطبيق، وزر لتفعيل/تعطيل RLS
 
- Confirm modal قبل تنفيذ أي تغيير
 

 
### 7.3 مثال pseudocode (React)
 `// مبدئي: استخدام hooks function RlsManager() {   const [tables,setTables]=useState([]);   useEffect(()=>{ fetch('/admin/tables', {headers: {'x-admin-key': ADMIN_KEY}}).then(r=>r.json()).then(setTables) },[]);   return (     <div className="grid">       <TableGrid tables={tables} />       <Sidebar />     </div>   ) } ` 
تفاصيل إضافية موجودة في الملحق البرمجي (الملف الكامل موجود في المستند).
  
# 8) الخوارزمية التحليلية (Heuristics) + اقتراح ML
 
### Heuristics (قواعد بسيطة لتوليد السياسات)
 
 
1. إذا وُجد `user_id` أو عمود ينتهي بـ `_user` → اقترح `user_isolation` باستخدام `auth.uid()`.
 
2. إذا وُجد `tenant_id` أو `org_id` → اقترح `tenant_isolation` باستخدام `current_setting('app.current_tenant')` أو claim في JWT.
 
3. إذا وُجد `owner_id` أو `created_by` → اقترح `owner_only` policy.
 
4. إذا تضمن الجدول أعمدة حسّاسة (`email`, `phone`, `ssn`, `password`, `card`) → زيّـد وزن الحساسية → اقترح `FOR ALL` مع check.
 
5. لو كان اسم الجدول أحد الجداول المرجعيّة (`countries`, `currencies`) → اقترح `readonly` أو لا سياسة.
 

 
### اقتراح ML مستقبلي
 
 
- اجمع بيانات التدريب: (table features → columns list, reltuples, previous decisions, نتيجة القرار)
 
- نماذج مقترحة: RandomForest أو LightGBM للتصنيف (Need RLS? نعم/لا/مستحسن)
 
- تحديث النموذج دورياً عبر تغييرات فعلية ونتائج الاختبارات.
 

  
# 9) آليات الأمان والـ Audit
 
 
- **مفتاح الخدمة**: فقط على الخادم، لا تعطيه للعميل.
 
- **دوال SECURITY DEFINER**: اجعل مالك الدوال هو حساب بامتيازات محدودة ومراقب.
 
- **سجل التغييرات (admin.audit_log)**: كل تغيير يُسجَّل مع actor وتوقيت والاستعلام المنفّذ.
 
- **النسخ الاحتياطي**: قبل تنفيذ تغييرات على جداول كبيرة، انشئ snapshot أو نسخة عبر `pg_dump` أو export.
 
- **اختبارات في Staging**: نفّذ السياسات أولًا في بيئة Staging.
 
- **صلاحيات**: حدّد من يمكنه استدعاء API عبر JWT/ApiKey وربطها بصلاحيات المستخدمين في نظامك.
 

  
# 10) اختبار، نشر، واسترجاع (rollback)
 
**اختبار محليًا / Staging:**
 
 
1. شغّل SQL على قاعدة staging.
 
2. نفّذ `GET /admin/tables` للتحقق من الإخراج.
 
3. نفّذ toggle على جدول غير حساس للتأكد من السلوك.
 

 
**نشر للإنتاج:**
 
 
1. خذ نسخة احتياطية (pg_dump).
 
2. طبّق الدوال SQL على Production عبر SQL editor أو CI pipeline.
 
3. نشر Backend مع متغيرات البيئة.
 
4. احرص على مراقبة الـ audit logs خلال 24-48 ساعة.
 

 
**Rollback:**
 
 
- لتنفيذ rollback لسياسة: استخدم `DROP POLICY` عبر admin.drop_policy أو نفّذ `ALTER TABLE ... DISABLE ROW LEVEL SECURITY` وارجع النسخة القديمة إذا لزم.
 

  
# 11) قوائم مراجعة (Checklist)
 
 
- [ ] إنشاء admin schema ودوال في Staging
 
- [ ] إنشاء audit_log
 
- [ ] اختبار toggle_rls و create_policy في Staging
 
- [ ] إنشاء Backend محمي وAPI
 
- [ ] صنع UI لعرض الجداول والتوصيات
 
- [ ] توثيق الإجراءات وأصحاب القرار
 
- [ ] نسخ احتياطي قبل التنفيذ في Production
 

  
# 12) ملاحق: أمثلة تنفيذية سريعة
 
**عرض الجداول:**
 `SELECT * FROM admin.list_tables_with_meta(); ` 
**تفعيل RLS على جدول:**
 `SELECT admin.toggle_rls('public','orders',true,'admin@company.com'); ` 
**إنشاء سياسة عزل مستخدم:**
 `SELECT admin.create_policy('public','orders','user_isolation','ALL','user_id = auth.uid()','user_id = auth.uid()','admin@company.com'); ` 
**حذف سياسة:**
 `SELECT admin.drop_policy('public','orders','user_isolation','admin@company.com'); `  
## نهاية المستند
 
هذا المستند مُصمَّم ليكون ملف مرجعي تطبيقي يمكنك نسخه ولصقه في SQL editor، وملفات الـ backend يمكنك رفعها مباشرة للخادم بعد ضبط متغيرات البيئة.