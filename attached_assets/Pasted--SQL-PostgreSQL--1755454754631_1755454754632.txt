رائع — سأبدأ بالخيار (أ) وأقدّم لك مخطّط قاعدة بيانات SQL جاهز (PostgreSQL) مع دوال مساعدة لتنفيذ تأكيد الفاتورة وتحويل البنود إلى سجلات أدوات مع تحديث المخزون وسجل الحركات. كل الشرح بالعربية ومصمّم ليكون قابلًا للتسليم للمطوّر مباشرة.

مخطط قاعدة البيانات (PostgreSQL) — CREATE TABLEs + دالة تأكيد فاتورة

-- تأكد من تفعيل الامتدادات الضرورية
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- قيم ثابتة (enum-like) عبر type
CREATE TYPE tool_status AS ENUM ('available','assigned','under_maintenance','lost','consumed','reserved');
CREATE TYPE location_type AS ENUM ('warehouse','project','external','none');
CREATE TYPE movement_type AS ENUM ('assign','return','transfer','consume','purchase','adjustment');
CREATE TYPE purchase_status AS ENUM ('draft','confirmed','cancelled');

-- جدول المستخدمين (مبسّط)
CREATE TABLE users (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  username text NOT NULL UNIQUE,
  full_name text,
  role text,
  email text,
  created_at timestamptz DEFAULT now()
);

-- الموردين
CREATE TABLE suppliers (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  name text NOT NULL,
  contact_info jsonb,
  created_at timestamptz DEFAULT now()
);

-- تصنيفات الأدوات
CREATE TABLE tool_categories (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  name text NOT NULL UNIQUE,
  parent_id uuid REFERENCES tool_categories(id) ON DELETE SET NULL
);

-- المشاريع
CREATE TABLE projects (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  code text,
  name text NOT NULL,
  site_address text,
  manager_id uuid REFERENCES users(id),
  created_at timestamptz DEFAULT now()
);

-- المخازن (لو في أكثر من مخزن)
CREATE TABLE warehouses (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  name text NOT NULL,
  location text,
  created_at timestamptz DEFAULT now()
);

-- جدول رئيسي للأدوات (Item master)
CREATE TABLE tools (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  sku text UNIQUE, -- رمز المخزون إن وُجد
  name text NOT NULL,
  category_id uuid REFERENCES tool_categories(id),
  unit text, -- قطعة/طقم/متر
  is_tool boolean DEFAULT true, -- اداة أم مادة مستهلكة
  is_consumable boolean DEFAULT false,
  serial_number text,
  purchase_ref uuid REFERENCES purchases(id),
  purchase_price numeric(12,2),
  acquisition_date date,
  status tool_status DEFAULT 'available',
  metadata jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- مخزون الأداة على مستوى موقع (مخزن/مشروع)
CREATE TABLE tool_stock (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tool_id uuid NOT NULL REFERENCES tools(id) ON DELETE CASCADE,
  location_type location_type NOT NULL,
  location_id uuid, -- مرجع إلى warehouses.id أو projects.id أو null
  quantity integer NOT NULL DEFAULT 0,
  UNIQUE (tool_id, location_type, location_id)
);

-- سجل الحركات/المدفوعات (Audit trail)
CREATE TABLE tool_movements (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tool_id uuid NOT NULL REFERENCES tools(id) ON DELETE CASCADE,
  from_type location_type,
  from_id uuid,
  to_type location_type,
  to_id uuid,
  quantity integer NOT NULL,
  movement_type movement_type NOT NULL,
  performed_by uuid REFERENCES users(id),
  performed_at timestamptz DEFAULT now(),
  notes text,
  ref_invoice_id uuid REFERENCES purchases(id)
);

-- جدول المشتريات والفواتير
CREATE TABLE purchases (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id uuid REFERENCES suppliers(id),
  created_by uuid REFERENCES users(id),
  status purchase_status DEFAULT 'draft',
  total_amount numeric(14,2) DEFAULT 0,
  currency text DEFAULT 'USD',
  created_at timestamptz DEFAULT now(),
  confirmed_at timestamptz
);

-- بنود الفاتورة: يمكن أن تكون أدوات أو مواد
CREATE TABLE purchase_items (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  purchase_id uuid NOT NULL REFERENCES purchases(id) ON DELETE CASCADE,
  sku text,
  name text NOT NULL,
  quantity integer NOT NULL DEFAULT 1,
  unit_price numeric(12,2) DEFAULT 0,
  is_tool boolean DEFAULT false,
  destination_type location_type DEFAULT 'warehouse', -- الوجهة المقصودة
  destination_id uuid, -- مرجع لمكان الاستلام (warehouse / project)
  notes text
);

-- سجل الصيانة
CREATE TABLE tool_maintenance_logs (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tool_id uuid NOT NULL REFERENCES tools(id),
  performed_by uuid REFERENCES users(id),
  performed_at timestamptz DEFAULT now(),
  notes text,
  next_due_date date,
  cost numeric(12,2)
);

-- فهرسات مفيدة
CREATE INDEX idx_tools_category ON tools(category_id);
CREATE INDEX idx_tool_stock_tool ON tool_stock(tool_id);
CREATE INDEX idx_movements_tool ON tool_movements(tool_id);
CREATE INDEX idx_purchase_items_purchase ON purchase_items(purchase_id);

-- ترويسة: Trigger لتحديث updated_at في tools تلقائياً
CREATE FUNCTION trg_tools_updated_at() RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;
CREATE TRIGGER tools_updated_at BEFORE UPDATE ON tools
FOR EACH ROW EXECUTE FUNCTION trg_tools_updated_at();

دالة مساعدة: confirm_purchase(purchase_id)

دالة تُنفّذ داخل معاملة واحدة: تختم الفاتورة (تغيّر الحالة إلى confirmed)، وتنشئ/تحدّث سجلات الأدوات (إن كانت البنود مُعلّمة كـ is_tool = true)، وتحدّث جدول tool_stock، وتضيف سجل حركة في tool_movements لكل بند.

CREATE OR REPLACE FUNCTION confirm_purchase(p_purchase_id uuid, p_performed_by uuid)
RETURNS void LANGUAGE plpgsql AS $$
DECLARE
  pi RECORD;
  tool_rec tools%ROWTYPE;
  t_id uuid;
  dest_type location_type;
  dest_id uuid;
BEGIN
  -- تحقق أن الفاتورة موجودة وفي الحالة draft
  PERFORM 1 FROM purchases WHERE id = p_purchase_id AND status = 'draft';
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Purchase % not found or not in draft state', p_purchase_id;
  END IF;

  FOR pi IN SELECT * FROM purchase_items WHERE purchase_id = p_purchase_id LOOP
    IF pi.is_tool THEN
      -- تحديد الوجهة
      dest_type := pi.destination_type;
      dest_id := pi.destination_id;

      -- حاول إيجاد أداة موجودة بنفس الـ SKU (إن وُجد)
      IF pi.sku IS NOT NULL THEN
        SELECT * INTO tool_rec FROM tools WHERE sku = pi.sku LIMIT 1;
      ELSE
        SELECT * INTO tool_rec FROM tools WHERE name = pi.name LIMIT 1;
      END IF;

      IF NOT FOUND OR tool_rec.id IS NULL THEN
        -- إنشاء أداة جديدة في حال عدم وجودها
        INSERT INTO tools (sku, name, category_id, unit, is_tool, is_consumable, purchase_ref, purchase_price, acquisition_date, metadata)
        VALUES (pi.sku, pi.name, NULL, NULL, true, false, p_purchase_id, pi.unit_price, now(), jsonb_build_object('created_from_purchase_item', pi.id))
        RETURNING id INTO t_id;
      ELSE
        t_id := tool_rec.id;
        -- تحديث purchase_ref فقط إذا لم يكن موجودًا
        UPDATE tools SET purchase_ref = COALESCE(purchase_ref, p_purchase_id) WHERE id = t_id;
      END IF;

      -- تحديث/إدخال المخزون في الوجهة (upsert)
      INSERT INTO tool_stock (tool_id, location_type, location_id, quantity)
      VALUES (t_id, dest_type, dest_id, pi.quantity)
      ON CONFLICT (tool_id, location_type, location_id)
      DO UPDATE SET quantity = tool_stock.quantity + EXCLUDED.quantity;

      -- إضافة سجل حركة من 'none' أو من مورد إلى الوجهة
      INSERT INTO tool_movements (tool_id, from_type, from_id, to_type, to_id, quantity, movement_type, performed_by, performed_at, notes, ref_invoice_id)
      VALUES (t_id, 'none', NULL, dest_type, dest_id, pi.quantity, 'purchase', p_performed_by, now(), concat('Purchase item ', pi.id), p_purchase_id);
    ELSE
      -- بند غير أداة: يمكن التعامل به بحسب سياسة الشركة (تخزين كنفقات/مواد لا يتم تسجيلها في tools)
      NULL;
    END IF;
  END LOOP;

  -- تحديث حالة الفاتورة
  UPDATE purchases SET status = 'confirmed', confirmed_at = now()
  WHERE id = p_purchase_id;

END;
$$;

ملاحظات عملية ونصائح تنفيذية

المخزون المركزي مقابل حساب الحقول: هنا استخدمت جدول tool_stock لتمثيل الكميات في كل موقع؛ هذا أسلوب آمن يسهل التعامل مع التحركات ويمنع تناقضات quantity_available المحسوبة محليًا.

التحقّقات المتزامنة: عند عمليات النقل الحيّة (sites) استخدم معاملات DB (transactions) وقفل الأسطر SELECT ... FOR UPDATE عند الحاجة لمنع نقل نفس القطعة مرتين.

الصور/الملفات: خزّن روابط الصور في S3 أو storage خارجي وسجّلها في tools.metadata -> image_urls.

التحليلات: لحساب الإحصاءات (Top 10 استخدام/نسبة استغلال) اجمع البيانات من tool_movements بحسب الفترات الزمنية.

أذونات: طبّق قيود في التطبيق (backend) بناء على أدوار المستخدمين قبل تنفيذ الدوال.

آلية الـRollback: أي خطأ في دالة confirm_purchase سيُلقِ بفشل المعاملة ولن يتغيّر شيء — هذا مطلوب للحفاظ على تناسق المخزون.

اختبارات: اكتب اختبارات لإجراءات التأكيد، النقل، الاستهلاك، وإرجاع العدة لتتأكّد من سلامة التحديثات في tool_stock و tool_movements.



---

إذا أردت الآن أستطيع فورًا الانتقال إلى:

الخيار ب) رسم واجهة (wireframe) كـ HTML/React + Tailwind قابلة للعرض في مشروع (سأضع مكوّن React واحد لصفحة قائمة الأدوات)،
أو

الخيار ج) كتابة مثال عملي في Node.js (Express) لواجهة POST /api/purchases/:id/confirm تستدعي الدالة confirm_purchase أو تقوم بنفس المنطق في التطبيق.


أي خيار تريده الآن؟ أبدأ مباشرة بالخيار الذي تختاره — أو لو تريد أقدّم كلا الحالتين (B ثم C) أعدّهما لك بدون انتظار.

