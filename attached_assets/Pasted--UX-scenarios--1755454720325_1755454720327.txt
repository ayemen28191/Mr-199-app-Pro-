جميل — سأعطيك توثيقًا مفصّلًا واحدًا شامل يصف تجربة المستخدم خطوة-ب-خطوة (UX scenarios) لكل زر، كل دالة/API، كل مكوّن واجهة، وكل تغيير قاعدة بيانات. الهدف: أن يكون المرجع كافياً للمطوّر والـQA وللمستخدم النهائي لفهم كل تفاعل وتحرك داخل صفحة "مخزن/معدات". سأرتّب المحتوى بحيث تقدر تنقله مباشرة إلى مستند التطوير.

مقدمة سريعة

التركيز هنا على صفحة "مخزن المعدات" (Mobile-first & Web). كل عملية عبارة عن سلسلة: تفاعل واجهة → مكوّنات فرونتند → استدعاء API → عمليات على DB → تحديث الواجهة وإشعارات → سجلّات (audit/log). سنشرح كل جزء ونعطي أمثلة Payloads ونتائج DB المتوقعة.


---

1 — مكوّنات الواجهة (Components) واربطها بالوظائف

1. TopBar

عناصر: بحث سريع (search input)، زر إنشاء جديد (+)، أيقونة إشعارات، زر الفلاتر.

وظيفة: يوجّه المستخدم للشاشة المناسبة أو يفتح مودال/شاشة فلترة.

تفاعلات:

البحث → يكتب المستخدم → يُرسَل GET /api/tools?q=... بعد 300ms debounce.

زر + → يفتح modal AddToolModal (see below).




2. TabsBar

تبويبات: المخزون العام / أدوات المشروع / سجل الحركات / تقارير.

وظيفة: تغير مصدر البيانات المعروض (params في API).



3. ToolsList/Grid

عرض: بطاقات أو صفوف لكل أداة.

كل صف/بطاقة تعرض: صورة صغيرة، الاسم، الكود (SKU)، qty available (في الموقع الحالي)، حالة (badge).

تفاعل على السطر:

النقر → يفتح ToolDetailsDrawer أو modal.

swipe left/right (mobile) → إجراءات سريعة: Transfer / Quick Return / Mark as Maint.




4. ToolDetailsDrawer (مكون أساسي)

أقسام: Overview | Movements | Maintenance | Purchase refs

أزرار رئيسية: Transfer، Return، Mark Consumed، Start Maintenance، Print / Export.

عند الضغط على أي زر يفتح فرم مختصر (BottomSheet) أو modal مع الحقول المطلوبة.



5. AddToolModal

حقول: name, sku, category, is_tool (checkbox), is_consumable, initial_location (warehouse/project), initial_qty, images, purchase_ref (اختياري).

زر: Save → يستدعي POST /api/tools.



6. TransferModal

حقول: to_type (project/warehouse), to_id (select), quantity, reason, transfer_date.

زر: Confirm → يستدعي POST /api/tools/:id/transfer أو POST /api/movements.



7. Return/SortScreen

عرض checklist للأدوات المرتبطة بمشروع محدد.

يعرض حالة كل معدّة (returned / missing / damaged) مع حقل ملاحظات وصور.

زر: Finalize Return → ينشئ حركات return + يطبع كشف استلام.



8. QR Scanner (Mobile)

مكوّن كاميرا يقرأ QR/Barcode وينادي endpoint GET /api/tools/by-code?code=... ويعرض تفاصيل أو يفتح عملية سريعة (Transfer/Return).



9. Notifications & Toasts

توست للسليم، خطأ، تنبيه انخفاض مخزون.

نظام إشعارات داخل التطبيق ورسائل إيميل/واتساب حسب إعدادات.



10. Offline Queue

مخزن محلي (IndexedDB) لحفظ العمليات عندما يكون أوفلاين، ومزامنة لاحقًا مع endpoint POST /api/sync/queue.





---

2 — APIs و الدوال الأساسية (مع أمثلة Payloads ونتائج)

سأذكر كل عملية رئيسية: endpoint، وصف، payload، ما يحدث في DB، استجابة متوقعة.

2.1 GET /api/tools

وصف: جلب قائمة الأدوات (supports filters: projectId, status, q, category, page).

مثال: GET /api/tools?projectId=uuid-123&status=assigned

نتيجة: JSON array مع حقول: id, name, sku, stock_by_location, status, image_urls.


2.2 POST /api/tools — إنشاء أداة (AddToolModal → Save)

Payload:


{
  "name":"مكينة لحام",
  "sku":"AD-0018",
  "is_tool": true,
  "is_consumable": false,
  "initial_location": { "type": "warehouse", "id": "wh-1" },
  "initial_qty": 1,
  "purchase_ref": "purchase-345",
  "metadata": { "serial":"SN-987" }
}

ما يحدث في DB:

Insert row in tools (id = tool-1).

Insert/Upsert into tool_stock (tool_id=tool-1, location_type=warehouse, location_id=wh-1, quantity=1).

Insert into tool_movements with movement_type='adjustment' أو 'purchase' (حسب الحالة).


استجابة: 201 Created + created tool object.


2.3 POST /api/purchases/:id/confirm — تحويل بنود الفاتورة لأدوات (إذا اخترت)

Payload: { "confirmed_by": "user-7", "convert_items": [ "purchase_item_id1", ... ] }

ما يحدث:

دالة confirm_purchase (التي سبق ذكرها) تنفّذ داخل معاملة DB: تنشئ/تحدّث tools, tool_stock, tool_movements, وتحدث حالة purchases.


استجابة: 200 + ملخّص ما تم إضافته/تحديثه.


2.4 POST /api/tools/:id/transfer

Payload:


{
  "to_type": "project",
  "to_id": "proj-52",
  "quantity": 1,
  "movement_type":"transfer",
  "performed_by":"user-7",
  "notes":"نقل لحاجة الحفر"
}

ما يحدث:

Transaction:

SELECT ... FOR UPDATE on tool_stock rows for tool_id at source location to ensure الكمية كافية.

Decrement quantity at source row; increment at dest row (insert if not exists).

Insert tool_movements record with from/to info.


If insufficient qty → rollback + return 400 error.


استجابة: 200 + updated stock.


2.5 POST /api/tools/:id/return

Payload similar to transfer but movement_type='return' and to_type likely 'warehouse' or 'central'.

ما يحدث: update stocks + movement log + optional create return_receipt PDF.


2.6 POST /api/tools/:id/consume — استهلاك/خسارة

Payload:


{ "quantity":2, "reason":"استهلاك في الموقع", "performed_by":"user-9" }

ما يحدث: decrement stock, insert movement_type='consume', set tools.status='consumed' if fully consumed.


2.7 GET /api/tools/:id/movements?from=&to=

جلب سجل الحركات لعرض التايملاين في ToolDetailsDrawer.


2.8 POST /api/sync/queue (Offline sync)

يتلقى قائمة عمليات محفوظة محليًا مع TTL.

Server يتعامل مع كل عملية كـ transaction ويحترم ترتيب timestamps أو user-provided sequence.



---

3 — سيناريوهات استخدام كاملة (UX flow خطوة بخطوة)

سأشرح 6 سيناريوهات حقيقية — كل سيناريو يوضح كل زر/مكوّن واستدعاءات backend وDB mutations والانتقالات في الواجهة.


---

سيناريو A — إضافة أداة يدوياً (Manual Add)

المستخدم يفعل:

1. يضغط زر + في TopBar → يفتح AddToolModal.


2. يملأ الحقول (name, sku, initial_qty=2, destination=Warehouse A) → يضغط Save.



ما الذي يحدث في الواجهة:

يعرض Loading spinner على زر Save.

عند نجاح العملية يظهر toast: "تم إضافة المكينة بنجاح" ويُغلَق المودال.

القائمة تُحدّث (optimistic update أو re-fetch).


استدعاء API:

POST /api/tools ببيانات الفرم.


على الـBackend/DB:

Insert INTO tools (new id).

Upsert INTO tool_stock for warehouse A quantity = 2.

Insert INTO tool_movements (movement_type='adjustment' أو 'purchase').


Audit & Notifs:

سجلّ tool_movements يحتوي من قام بالعملية والوقت.

إشعار لمدير المخزن (إذا مفعل).


Edge cases:

إذا sku موجود → backend يرجّع 409 conflict أو يزيد الكمية بدل الإنشاء (اعتمادًا على سياسة).

واجهة تعرض رسالة توضيحية: "SKU موجود — هل تريد زيادة الكمية؟"



---

سيناريو B — إضافة أدوات من الفاتورة (Purchase → Convert to Tools)

المستخدم يفعل:

1. في صفحة Purchases، يفتح فاتورة بها بنود.


2. يعلّم خانة is_tool على بند المكينة ويحدد الوجهة Warehouse B.


3. يضغط Confirm Purchase.



ما الذي يحدث:

زر Confirm يعرض modal تأكيد: "هل تحويل البنود كأدوات؟"

عند الموافقة، زر Confirm يستدعي API ويعرض progress.

خلفيًا ستُنفّذ الدالة confirm_purchase.


استدعاءات:

POST /api/purchases/:id/confirm مع user id و convert items.


في DB:

لكل بند marked as is_tool:

إن لم يوجد tool بسِكَّه → INSERT tools.

Upsert tool_stock لوجهة الوجهة.

Insert tool_movements with movement_type='purchase', ref_invoice_id=purchase.id.


purchase.status -> 'confirmed'.


الواجهة بعد النجاح:

toast: "تم تأكيد الفاتورة وإضافة 3 أدوات إلى المخزن B".

تحديث في صفحة Tools (يمكن فتح إشعار يقود للمخزن/الأداة الجديدة).


حالات خطأ:

خطأ أثناء المعاملة → rollback بالكامل + رسالة خطأ عامة مع رابط لإعادة المحاولة أو لعرض الـlog.



---

سيناريو C — نقل أداة من مشروع A إلى مشروع B

المستخدم يفعل:

1. يفتح Project A → يختار "قائمة الأدوات" → يعلّق على "مكينة لحام".


2. يختار Transfer (من بطاقة الأداة أو من خلال ToolDetails) → يملأ الوجهة Project B + qty=1 + reason → Confirm.



الواجهة:

يظهر modal Transfer → Confirm → Spinner.

بعد النجاح، تظهر رسالة: "تم نقل 1 مكينة إلى مشروع B".

في Project A: qty ينقص. في Project B: qty يزيد (if previously zero → يظهر أداة الآن).


Backend:

Transaction:

SELECT tool_stock WHERE tool_id=... AND location_type='project' AND location_id='proj-A' FOR UPDATE

validate qty >= requested

update source.qty -= 1

insert or update dest (proj-B) qty +=1

insert movement record (from project A → project B)


return 200 + updated stocks.


Notifications:

إشعار إلى مدير مشروع B: "تم استقبال مكينة لحام (1) — مرجع: ...".


Edge:

لو مافيش كمية كافية → 400 مع نص "الكمية المطلوبة غير متوفرة. المتاح: X".



---

سيناريو D — إرجاع العدة عند الانتهاء (Sort for Departure)

المستخدم يفعل:

1. من شاشة Project → يضغط Sort for Departure أو enters Return Mode.


2. يعرض النظام قائمة الأدوات المعارة (checkbox لكل عنصر).


3. العمال/مشرفون يقومون بفحص وإستخدام QR لمسح كل معدّة وتعيين الحالة: returned / missing / damaged مع صورة وملاحظة.


4. بعد الانتهاء يضغط Finalize Return.



الواجهة:

تقدم progress bar (مثلاً: 12/20 items scanned).

زر Finalize يُظهر ملخص: Returned: 10, Missing: 2, Damaged: 0.

خيار طباعة كشف استلام يفتح PDF modal.


Backend:

لكل عنصر marked returned:

POST /api/tools/:id/return أو batch POST /api/movements/batch.

update tool_stock: decrement from project, increment to warehouse (or central).

insert movement log (type='return') with images in metadata.


For missing/damaged → create movement_type='consume' أو 'lost' + create incident ticket.


Audit & Reports:

Generate return_report record with sign-off fields (received_by, delivered_by, date) and attach images.


Edge:

Partial returns → system allows creating a pending list for follow-up.



---

سيناريو E — استهلاك / فقدان / عطل

المستخدم يفعل:

1. من ToolDetails → يضغط Mark as Consumed أو Report Damage.


2. يملأ qty, notes, يرفق صورة (اختياري) → Submit.



Backend:

Decrement stock accordingly.

Insert tool_movements with movement_type='consume' أو 'lost'.

If tool is unique (serial) and fully lost → update tools.status='lost'.


UI:

Warn modal: "هذه العملية لا يمكن التراجع عنها بسهولة. هل متأكد؟"

بعد نجاح: toast + عرض زر لإنشاء طلب شراء بديل (Quick Purchase Suggestion).



---

سيناريو F — صيانة دورية (Maintenance)

المستخدم يفعل:

1. في ToolDetails → يضغط Maintenance → Schedule Maintenance أو Log Maintenance.


2. يملأ details و next_due_date و cost → Save.



DB:

Insert into tool_maintenance_logs.

Update tools.metadata (last_maintenance_date).

If next_due_date قريب → set alert job to notify قبل X أيام.


UI:

في لوحة الإحصائيات: يظهر عدد الأدوات بحاجة صيانة.

عند فتح ToolDetails → Tab Maintenance يعرض history.



---

4 — خرائط الأزرار/المكوّنات إلى دوال (Button → Component → API → DB)

سأعطي جدول مبسّط (يمكن نسخه كمرجع):

زر + → AddToolModal → POST /api/tools → INSERT tools + INSERT tool_stock + INSERT tool_movements

زر Confirm Purchase → Purchases Page → POST /api/purchases/:id/confirm → confirm_purchase() (creates tools/stock/movements)

زر Transfer (card/detail) → TransferModal → POST /api/tools/:id/transfer → UPDATE tool_stock (source/dest) + INSERT tool_movements

زر Return (project list) → ReturnScreen → POST /api/movements/batch → batch UPDATE tool_stock + INSERT tool_movements + generate return report

زر Consume → POST /api/tools/:id/consume → UPDATE tool_stock - INSERT tool_movements - maybe UPDATE tools.status

زر Schedule Maintenance → POST /api/tools/:id/maintenance → INSERT tool_maintenance_logs + schedule reminders



---

5 — حالات الصلاحيات والـConfirmations

كل عملية حساسة (حذف معدّة، استهلاك كامل، تأكيد فاتورة) تطلب modal تأكيد مع إظهار من قام بالعملية (user) وربما حق إدخال reason.

صلاحيات:

Admin = كل شيء

Warehouse Manager = إضافة/نقل/confirm purchases/exports

Site Foreman = طلب/استلام/return

Viewer = عرض فقط


API يقوم بالتحقق من الدور قبل تنفيذ أي تحديث.



---

6 — التعامل مع التزامن (Concurrency) وسلامة البيانات

استخدم معاملات DB (BEGIN/COMMIT) وSELECT ... FOR UPDATE على صفوف tool_stock قبل تعديل الكمية.

عمليات الـTransfer/Consume يجب أن تفشل (rollback) إذا الكمية غير كافية.

إضافة رقم تسلسلي (serial_number) لكل قطعة فردية جعل تتبعها أسهل وتمنع double-assignment.



---

7 — الرسائل، حالات الخطأ، وUX microcopy المقترح

Success toasts:

"تمت إضافة المكينة بنجاح."

"تم نقل 1 وحدة إلى مشروع X."


Warnings:

"الكمية المطلوب نقلها أكبر من المتاح (المتاح: 2)."

"عميلة نهائية — لا يمكن التراجع؟"


Errors:

"فشل في الاتصال. سيتم الحفظ محليًا وسيتم المزامنة تلقائيًا."

"فشل التحقق من الصلاحية — لا تملك إذناً لتنفيذ العملية."


Loading states: disable buttons أثناء المعاملة، show skeletons عند تحميل القوائم الطويلة.



---

8 — أمثلة Payload JSON ونتائج DB (مثال عملي نقل)

Request POST /api/tools/uuid-tool-123/transfer

{
  "to_type":"project",
  "to_id":"proj-52",
  "quantity":1,
  "performed_by":"user-7",
  "notes":"نقل لمرحلة الحفر"
}

Server flow (pseudo)

1. BEGIN TRANSACTION


2. SELECT tool_stock WHERE tool_id=... AND location_type='project' AND location_id='proj-31' FOR UPDATE


3. IF available_qty < 1 -> ROLLBACK & return 400


4. UPDATE tool_stock SET quantity = quantity - 1 WHERE ...


5. INSERT INTO tool_stock (tool_id, location_type='project', location_id='proj-52', quantity=1) ON CONFLICT DO UPDATE ADD


6. INSERT INTO tool_movements (...)


7. COMMIT



Response

{ "status":"ok", "message":"تم النقل", "stock": { "proj-31": 0, "proj-52": 1 } }


---

9 — تقارير مقترحة قابلة للتنفيذ فورًا

تقرير "أدوات معارة الآن" = SELECT tool_id, SUM(quantity) FROM tool_stock WHERE location_type='project' GROUP BY tool_id

تقرير "Top used" = SELECT tool_id, COUNT(*) as transfers FROM tool_movements WHERE movement_type='transfer' AND performed_at BETWEEN X AND Y GROUP BY tool_id ORDER BY transfers DESC LIMIT 10

قالب "كشف العدة" للـReturn: generate PDF with list + signatures.



---

10 — نقاط فنية أخيرة (نُصائح للتنفيذ)

1. API idempotency: لكل عملية حساسة، تقبل idempotency_key لتجنب التكرار عند إعادة الإرسال (mobile offline retries).


2. Caching & Pagination: جلب القوائم الكبيرة يحتاج pagination + lazy loading + server-side search.


3. Audit trail: كل تحديث مهم يجب يتضمن performed_by و timestamp و device_id إن أمكن.


4. صور/ملفات: ارفع الصور قبل finalizing أو اجعلها attachments referential لأسهل التعامل.


5. Testing: اختبر حالات race conditions (مثلاً 2 مستخدمين ينقلان نفس الأداة في نفس الوقت).


6. UX: خفّف من الحقول على الموبايل — استخدم bottom-sheet forms قصيرة.




---

إذا رغبت أستطيع الآن (أحد الخيارات فورًا):

أ) أن أكتب مخططًا تفصيليًا لملف ToolDetailsDrawer كمكوّن React + Tailwind (JSX) مع كل زر واستدعاء API مفصّل (شيفرة قابلة للنسخ).

ب) أن أعدّ ملفات End-to-End scenarios بصيغة خطوات يمكن لفريق QA تنفيذها.

ج) أن أنشئ JSON Schema لكل endpoint لتسليمها للفريق التقني.


أخبرني أي واحد تريده الآن وسأعطيه لك فورًا.

